// Generated by CoffeeScript 2.3.1
// NB: No longer saving to bucket, using Cloudflare cache.
// storage = require("@google-cloud/storage")()
// bucket = storage.bucket("#{process.env.bucket}")

// Get whether a file exists in a bucket.

// @param {string} name - Name of the file.
// @returns {promise<boolean>} - Whether the file exists.
var compose, crop, exists, express, image, os, port, profile, read, render, renderFor, request, resize, resizeCoef, save, savePng, sharp, texture;

exists = function(name) {
  return bucket.file(name).exists().then(function(data) {
    return data[0];
  });
};

// Create a read stream to access a file.

// @param {string} name - Name of the file.
// @returns {readablestream} - A readable stream of the file.
read = function(name) {
  return bucket.file(name).createReadStream();
};

// Save a raw data file into a bucket.

// @param {string} name - Path name of the file.
// @param {object|buffer} data - Raw data file.
// @param {string} type - Type of data file (ie. application/json).
// @param {integer} ttl - Cache in seconds of the file.
save = function(name, data, type, ttl) {
  return bucket.file(name).save(data, {
    contentType: type,
    gzip: true,
    public: true,
    resumable: false,
    validation: false,
    metadata: {
      cacheControl: `public, max-age=${ttl}`
    }
  });
};

// Save a PNG file into a bucket.

// @param {string} name - Path name of the file.
// @param {buffer} buf - Image buffer.
savePng = function(name, buf) {
  return save(name, buf, "image/png", 604800);
};

os = require("os");

sharp = require("sharp");

// Safely perform mutation operations on an image buffer.

// @param {buffer} buf - Image buffer.
// @returns {sharp} - Cloned image buffer with the sharp module.
image = function(buf) {
  return sharp(buf).clone();
};

// Crop out a section of an image buffer.

// @param {buffer} buf - Image buffer.
// @param {integer} x - Left-hand upper corner x-coordinate.
// @param {integer} y - Left-hand upper corner y-coordinate.
// @param {integer} w - Width in pixels of the crop section.
// @param {integer} h - Height in pixels of the crop section.
// @returns {promise<buffer>} - Image buffer of the cropped section.
crop = function(buf, x, y, w, h) {
  return image(buf).extract({
    left: x,
    top: y,
    width: w,
    height: h
  }).toBuffer();
};

// Place one image buffer on top of another.

// @param {buffer} buf0 - Image buffer at the bottom.
// @param {buffer} buf1 - Image buffer placed on top.
// @param {integer} x - Left-hand upper corner x-coordinate to place image.
// @param {integer} y - Left-hand upper corner y-coordinate to place image.
// @returns {promise<buffer>} - Image buffer with the composed image.
compose = function(buf0, buf1, x = 0, y = 0) {
  return image(buf0).overlayWith(buf1, {
    left: x,
    top: y
  }).toBuffer();
};

// Resize an image to a new width and height.

// Uses the nearestNeighbor algorithm to keep
// pixel density without blurring.

// @param {buffer} buf - Image buffer to resize.
// @param {integer} size - Width and height in pixels of the new image.
// @returns {promise<buffer>} - Image buffer of resized image.
resize = function(buf, size) {
  size = Math.max(0, size);
  return image(buf).resize(size * resizeCoef, size * resizeCoef, {
    kernel: sharp.kernel.nearest,
    interpolator: sharp.interpolator.nearest,
    centerSampling: true
  }).png().toBuffer();
};

resizeCoef = 2;

// Reduce IO operations because of impodency.
sharp.cache({
  memory: os.freemem() * 1000 / 2
});

// Allocate dedicated threads to process images.
sharp.concurrency(8);

// Enable special image vectoring to improve IO performance.
sharp.simd(true);

// Render the avatars of a user given their UUID or username.

// @param {string} id - UUID or username.
// @returns {promise<buffer>} - Image buffer of face and hat.
renderFor = function(id, size) {
  return profile(id).then(function(data) {
    id = data.uuid_dashed;
    return texture(data);
  }).then(function(buf) {
    return render(buf, size);
  });
};

// Render an avatar given the texture image of a user.

// @param {buffer} buf - Image buffer of textures.
// @param {integer} size - Size in pixels to transform the image.
// @returns {promise<buffer>} - Image buffer of face and hat.
render = function(buf, size) {
  return Promise.all([crop(buf, 8, 8, 8, 8), crop(buf, 40, 8, 8, 8)]).then(function([face, hat]) {
    return compose(face, hat);
  }).then(function(both) {
    return resize(both, size);
  });
};

express = require("express")();

port = process.env.PORT || 3000;

express.get("/:id?/:size?", function(req, res) {
  var id, size, start;
  start = new Date();
  id = req.params.id || "Steve";
  size = Math.min(1024, Math.max(8, parseInt(req.params.size) || 8));
  return renderFor(id, size).then(function(buf) {
    res.set("Content-Type", "image/png");
    res.status(200).send(buf);
    return "OK";
  }).catch(function(err) {
    res.set("Content-Type", "text/plain");
    res.status(500).send(err);
    return "ERROR";
  }).then(function(status) {
    var duration, ip;
    duration = new Date().getTime() - start.getTime();
    ip = req.get("CF-Connecting-IP") || req.ip;
    return console.log(`[${status}] ${ip} -> /${id}/${size} (${duration}ms)`);
  });
});

express.enable("trust proxy", true);

express.listen(port, function() {
  return console.log(`[INFO] Listening on ${port}...`);
});

request = require("request-promise-cache");

// Fetch the user profile from a UUID or username.

// @param {string} id - UUID or username.
// @returns {promise<object>} - User profile as JSON.
profile = function(id) {
  return request({
    uri: `https://ashcon.app/minecraft/user/${id}`,
    json: true,
    cacheKey: `profile/${id}`,
    cacheTTL: 86400
  });
};

// Fetch and download as a buffer the skin texture artifact.

// @param {object} profile - User profile.
// @param {promise<buffer>} - Image buffer.
texture = function(data) {
  return request({
    uri: data.textures.skin,
    encoding: null,
    cacheKey: `texture/${data.uuid}`,
    cacheTTL: 86400
  // BUG: Cached requests do not return Buffer, but an object containing it
  }).then(function(buf) {
    if (Buffer.isBuffer(buf)) {
      return buf;
    } else {
      return Buffer.from(buf.data);
    }
  });
};
