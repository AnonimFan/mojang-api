// Generated by CoffeeScript 2.3.1
var compose, crop, image, os, profile, render, renderFor, request, resize, resizeCoef, sharp, texture;

exports.get = function(req, res) {
  var id, size;
  [id, size] = req.url.split("/").slice(1, 3);
  if (id == null) {
    id = "Steve";
  }
  size = Math.min(1024, Math.max(8, parseInt(size) || 8));
  return renderFor(id, size).then(function(buf) {
    res.set("Content-Type", "image/png");
    return res.status(200).send(buf);
  }).catch(function(err) {
    console.error(err);
    res.set("Content-Type", "text/plain");
    return res.status(500).send(`Internal Error - ${err}`);
  });
};

request = require("request-promise-cache");

// Fetch the user profile from a UUID or username.

// @param {string} id - UUID or username.
// @returns {promise<object>} - User profile as JSON.
profile = function(id) {
  return request({
    uri: `https://ashcon.app/minecraft/user/${id}`,
    json: true,
    cacheKey: `profile/${id}`,
    cacheTTL: 86400
  });
};

// Fetch and download as a buffer the skin texture artifact.

// @param {object} profile - User profile.
// @param {promise<buffer>} - Image buffer.
texture = function(data) {
  return request({
    uri: data.textures.skin,
    encoding: null,
    cacheKey: `texture/${data.uuid}`,
    cacheTTL: 86400
  // BUG: Cached requests do not return Buffer, but an object containing it
  }).then(function(buf) {
    if (Buffer.isBuffer(buf)) {
      return buf;
    } else {
      return Buffer.from(buf.data);
    }
  });
};

// Render the avatars of a user given their UUID or username.

// @param {string} id - UUID or username.
// @returns {promise<buffer>} - Image buffer of face and hat.
renderFor = function(id, size) {
  return profile(id).then(function(data) {
    id = data.uuid_dashed;
    return texture(data);
  }).then(function(buf) {
    return render(buf, size);
  });
};

// Render an avatar given the texture image of a user.

// @param {buffer} buf - Image buffer of textures.
// @param {integer} size - Size in pixels to transform the image.
// @returns {promise<buffer>} - Image buffer of face and hat.
render = function(buf, size) {
  return Promise.all([crop(buf, 8, 8, 8, 8), crop(buf, 40, 8, 8, 8)]).then(function([face, hat]) {
    return compose(face, hat);
  }).then(function(both) {
    return resize(both, size);
  });
};

os = require("os");

sharp = require("sharp");

// Safely perform mutation operations on an image buffer.

// @param {buffer} buf - Image buffer.
// @returns {sharp} - Cloned image buffer with the sharp module.
image = function(buf) {
  return sharp(buf).clone();
};

// Crop out a section of an image buffer.

// @param {buffer} buf - Image buffer.
// @param {integer} x - Left-hand upper corner x-coordinate.
// @param {integer} y - Left-hand upper corner y-coordinate.
// @param {integer} w - Width in pixels of the crop section.
// @param {integer} h - Height in pixels of the crop section.
// @returns {promise<buffer>} - Image buffer of the cropped section.
crop = function(buf, x, y, w, h) {
  return image(buf).extract({
    left: x,
    top: y,
    width: w,
    height: h
  }).toBuffer();
};

// Place one image buffer on top of another.

// @param {buffer} buf0 - Image buffer at the bottom.
// @param {buffer} buf1 - Image buffer placed on top.
// @param {integer} x - Left-hand upper corner x-coordinate to place image.
// @param {integer} y - Left-hand upper corner y-coordinate to place image.
// @returns {promise<buffer>} - Image buffer with the composed image.
compose = function(buf0, buf1, x = 0, y = 0) {
  return image(buf0).overlayWith(buf1, {
    left: x,
    top: y
  }).toBuffer();
};

// Resize an image to a new width and height.

// Uses the nearestNeighbor algorithm to keep
// pixel density without blurring.

// @param {buffer} buf - Image buffer to resize.
// @param {integer} size - Width and height in pixels of the new image.
// @returns {promise<buffer>} - Image buffer of resized image.
resize = function(buf, size) {
  size = Math.max(0, size);
  return image(buf).resize(size * resizeCoef, size * resizeCoef, {
    kernel: sharp.kernel.nearest,
    interpolator: sharp.interpolator.nearest,
    centerSampling: true
  }).png().toBuffer();
};

resizeCoef = 2;

// Reduce IO operations because of impodency.
sharp.cache({
  memory: os.freemem() * 1000 / 2
});

// Allocate dedicated threads to process images.
sharp.concurrency(8);

// Enable special image vectoring to improve IO performance.
sharp.simd(true);
